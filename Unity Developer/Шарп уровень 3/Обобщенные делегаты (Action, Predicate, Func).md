Синтаксис лямбда-выражений обобщенных делегатов (анонимных функций):
`` Action(1)<>(2) action(3) = (x)(4) =>(5) Console.WriteLine(x)(7);
1. Тип делегата: Action, Predicate, Func
2. Обобщение (дженерик-тип)
3. Переменная делегата
4. Аргумент функции
5. Лямбда
6. Действие
7. Аргумент функции из пункта 4.

### #Action

Делегат Action - представляет некоторое действие, которое ничего не возвращает, то есть в качестве возвращаемого типа имеет тип void:

```
public delegate void Action();
public delegate void Action<in T>(T obj);
...
public delegate void Action<in T1, in T2,... in T16>(T obj);
```

Пример:
`` Action<int> action = (x) => Console.WriteLine(x);

### #Predicate 

Делегат Predicate<Т> - принимает один параметр и возвращает значение типа bool:
``delegate bool Predivate<in T>(T obj);

Пример:
``Predicate<int> isPositive = (int x) => x > 0;

### #Func

Делегат Func<оut Т> - возвращает результат действия и может принимать параметры. Он также имеет различные формы:

от ``Func<оut Т>()``, где Т - тип возвращаемого значения
до ``Func<in T1, in T2,....in T16, out TResult>();``

То есть может принимать до 16 параметров.

``TResult Func<out TResult>();
``TResult Func<in T, out TResult>(T arg);

``TResult Func<in T1, in T2,...in T16, out TResult>();

Пример:
``Func<int, int, string> f5 = (n1, n2) => (n1 + n2).ToString();

### Операции linq

Стандартные операции:
1. Фильтрация:
Операция, результатом которой будет набор значений, подходящий под определенное условие.
Фильтрация данных представлена следующими методами:
- OfType - фильтрует данные по типу,
- Where - фильтрует значения по условию (в декларативном синтаксисе - where).
```
// Where
string[] words = ["the", "quick", "brown", "fox", "jumps"];

//не декларативный
IEnumerable<string> query = from word in words
							where word.Length == 3
							select word;

//декларативный
IEnumerable<string> query2 = 
	words.Where(word => word.Lenght == 3);

foreach (string str in query)
	Console.WriteLine(str);

// OfType

List<IPerson> peoples = new List<IPerson>()
{
	new Child {},
	new Child {},
	new Parent {}
};

var onlyChilds = peoples.OfType<Child>().ToList();
```

2. Проекция:
Операция преобразования объекта в новую форму, которая часто состоит только из свойств этого объекта, которая впоследствии используется.
![[Pasted image 20250127172820.png]]
Проекция данных представлена следующими методами:
- Select - проецирует значения, которые основаны на функции преобразования (в декларативном синтаксисе select),
- SelectMany - проецирует последовательности значений, основанных на функции преобразования, а затем выравнивает их в одну последовательность (в декларативном синтаксисе множественный from). Простыми словами - забирает последовательность из элемента коллекции и кладет его в результирующую последовательность,
- Zip - создает последовательность кортежей из 2-3 указанных последовательностей.

```
// Select
string[] words = ["an", "apple", "a", "day"];

var query = from word in words
			select word.Substring(0, 1);

query = words.Select(word => word.Substring(0, 1));

foreach(string s in query)
	Console.WriteLine(s);

// SelectMany
List<string> phrases = ["an apple a day", "the quick brown fox"];

query = from phrase in phrases
		from word in phrase.Split(' ')
		select word;
query = phrases.SelectMany(phrases => phrases.Split(''));

foreach(string s in query)
	Console.Write(s);

// Zip
IEnumerable<int> numbers = [1, 2, 3, 4, 5, 6, 7];
IEnumerable<char> letters = ['A', 'B', 'C', 'D', 'E', 'F'];

var zip = numbers.Zip(letters);
IEnumerable<ZipType> zip2 = numbers.Zip(letters, (number, letter) => new ZipType { Num = number, Letter = letter });

class ZipType
{
	public int Num {get; set;}
	public char Letter {get; set;}
}
```
3. Операция над множествами:
В данном случае понимают операции запросов, которые создают результирующий набор присутствия или отсутствия эквивалентных элементов в одной или отдельной коллекциях.
- Distinct или DistinctBy - возвращает уникальные элементы последовательностей. Можно сказать, что удаляет дубликаты
``a,b,b,c,d,c ----> a,b,c,d

- Except или ExceptBy - возвращает набор значений, которые присутствуют в одной коллекции и отсутствуют в другой
```
a,b,c,e
		Итог операции = b;
a,c,d,e
```

- Intersect или IntersectBy - возвращает набор значений, которые встречаются в обоих коллекция
```
a,b,c,e
		Итог операции = a,c,e
a,c,d,e
```

- Union или UnionBy - возвращает набор уникальных значений, присутствующий в обоих коллекциях
```
a,b,c,e
		Итог операции = a,b,c,d,e;
a,c,d,e
```

4. Сортировка:
Операция сортировки - упорядочивает элементы последовательности на основе одного или нескольких атрибутов.

- OrderBy - сортировка значений в возрастающем порядке. В декларативном синтаксисе - оператор orderby или orderby ascending
- OrderByDescending - сортировка в убывающем порядке. В декларативном синтаксисе - оператор orderby descending
- ThenBy - дополнительная сортировка по возрастанию. В декларативном дополнительные - операторы orderby или orderby ascending
- ThenByDesсending - дополнительная сортировка по убыванию. В декларативном синтаксисе дополнительные orderby descending
- Reverse - изменение порядка элементов в коллекции на обратный. В декларативном синтаксисе аналогов нет.

5. Квантификаторы:
Это операция, которая возвращает значение bool, которой указывает, удовлетворяют ли условию некоторые или все элементы в последовательности.

- All - определяет, все ли элементы последовательности удовлетворяют условию.
- Any - определяет, удовлетворяют ли условию какие-либо элементы последовательности.
- Contains - определяет, содержит ли последовательность указанный элемент.

6. Секционирование:
Это операция разделения входной последовательности на разделы без изменения элементов, а затем возвращения одного из разделов.

- Skip - пропускает элементы до указанной позиции в последовательности
- SkipWhile - пропускает элементы на основе функции предиката, пока элемент не удовлетворяет условию
- Take - возвращает элементы на указанную позицию в последовательности
- TakeWhile - принимает элементы на основе функций предиката, пока элемент не удовлетворяет условию
- Chunk - разделяет элементы последовательности на фрагменты указанного максимального размера

7. Конвертация(преобразование) типов данных:
- AsEnumerable - Возвращает входные данные, введенные как IEnumerable<Т>
- AsQueryable - Преобразует (универсальный) [IEnumerable](https://learn.microsoft.com/en-us/dotnet/api/system.collections.ienumerable) в (универсальный) [IQueryable](https://learn.microsoft.com/en-us/dotnet/api/system.linq.iqueryable)
- Cast - Приводит элементы коллекции к указанному типу
- OfType - Фильтрует значения в зависимости от их возможности приведения к указанному типу
- ToArray - Преобразует коллекцию в массив. Этот метод принудительно выполняет запрос
- ToDictionary - Добавляет элементы в [словарь<TKey,TValue>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2) на основе функции выбора ключа. Этот метод принудительно выполняет запрос
- ToList - Преобразует коллекцию в список [<Т>](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1). Этот метод принудительно выполняет запрос.
- ToLookup - Помещает элементы в [Lookup<TKey,TElement>](https://learn.microsoft.com/en-us/dotnet/api/system.linq.lookup-2) (словарь «один ко многим») на основе функции выбора ключа. Этот метод принудительно выполняет запрос.

8. Операции соединения:
Соединение двух источников данных - связь объектов в одном источнике данных с объектами, которые имею общий атрибут в другом источнике данных.

- Join - соединяет две последовательности на основе функций селектора ключа и группирует полученные при сопоставлении данные для каждого элемента. В декларативном синтаксисе дополнительные join, in, on, equals
- GroupJoin - соединяет две последовательности на основе функции селектора ключа и группирует полученные при сопоставлении данные для каждого элемента. В декларативном синтаксисе дополнительные join, in, on, equals, into

Пример декларативного синтаксиса:
```
from x in set1
join y in set2 on y.Prop2 equals x.Prop1

где свойства y.Prop2 и x.Prop1 - являются одной и той же сущностью, скажем идентификаторы группы студента
```

9. Группировка данных:
Это операция объединения данных в группы таким образом, чтобы у элементов в каждой группе был общий атрибут. 

- GroupBy - группирует элементы с общим атрибутом. Объект представляет каждую IGrouping<ТKey, ТElement> группу. В декларативном синтаксисе group...by или group...by...into
- ToLookup - вставляет элементы в Lookup<ТKey, ТElement> (словарь "один ко многим") в зависимости от функций выбора ключа.

![[Pasted image 20250128161556.png]]

10. Агрегация данных:
Агрегатная функция выполняет вычисления над набором значений и возвращает одно значение.

- Count() - выполняет подсчет элементов по заданному селектору ключа
- Average() - выполняет подсчет элементов по заданному селектору ключа
- Min() - выполняет поиск минимального элемента по заданному селектору ключа
- Max() - выполняет поиск максимального элемента по заданному селектору ключа
- Sum() - вычисляет сумму последовательностей значений

11. Функции атомарного результата:
Атомарный результат(единственное значение), возвращает следующие функции:
- Single, SingleOrDefault - возвращает единичное значение. Если значение не единственное, то будет брошено исключение
- First, FirstOrDefault - возвращает первое вхождение элемента коллекции, удовлетворяющего условию
- Last, LastOrDefault - возвращает последнее вхождение элемента коллекции, удовлетворяющего условию
### Дополнения:

1. Компаратор
Интерфейсы:
- IComparer<Т>
- IComparable<Т>